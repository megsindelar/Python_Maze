from turtle import fd
import numpy as np
import random

#call to check for walls around a certain spot
def findwalls(cell):
    north = [cell[0]-1, cell[1]]
    fnorth = [cell[0]-2, cell[1]]
    south = [cell[0]+1, cell[1]]
    fsouth = [cell[0]+2, cell[1]]
    east = [cell[0], cell[1]+1]
    feast = [cell[0], cell[1]+2]
    west = [cell[0], cell[1]-1]
    fwest = [cell[0], cell[1]-2]

    if maze[north[0],north[1]] == -1:
        if maze[fnorth[0],fnorth[1]] ==-1:
            walls.append(north)

    if maze[south[0], south[1]] == -1:
        if maze[fsouth[0], fsouth[1]] == -1:
            walls.append(south) 

    if maze[east[0], east[1]] == -1: 
        if maze[feast[0], feast[1]] == -1:
            walls.append(east)

    if maze[west[0], west[1]] == -1:
        if maze[fwest[0], fwest[1]] == -1:
            walls.append(west)

#set the size of the playable matrix
rows = 10
columns = 10

#create a matrix of the specified size then fill with -1's
maze = np.zeros((rows, columns))
maze.fill(-1)

#add padding around the maze :)
maze = np.pad(maze, pad_width=1, mode='constant', constant_values=-2)

walls = []
initalwalls = []

#put all legal indexes into walls
for indexr, row in enumerate(maze): 
        for indexc, num in enumerate(row):
            if maze[indexr, indexc] != -2:
                initalwall = [indexr, indexc]
                initalwalls.append(initalwall)

#pick B from random index in walls and set to 0
B = random.randint(0,len(initalwalls)-1)
setB = initalwalls[B]
maze[setB[0], setB[1]] = 0
print(maze)

findwalls(setB)
print(walls)
print('walls!',walls)
badwalls = []

while len(walls)>0:
    #numfree = 2
    print("hi", walls)
    #while numfree > 1:
        #pick C randomly from the list of walls
    C = random.randint(0,len(walls)-1)
    setC = walls[C]
    print(setC)

    #find B relative to C
    Cnorth = [setC[0]-1, setC[1]]
    Csouth = [setC[0]+1, setC[1]]
    Ceast = [setC[0], setC[1]+1]
    Cwest = [setC[0], setC[1]-1]
    ccheck = [maze[Cnorth[0],Cnorth[1]], maze[Csouth[0], Csouth[1]],
            maze[Ceast[0], Ceast[1]], maze[Cwest[0], Cwest[1]]]
    #look for 0's around 
    for x, dir in enumerate(ccheck):
            if dir == 0 and x ==0:
                setB = Cnorth
            if dir == 0 and x ==1:
                setB = Csouth
            if dir == 0 and x ==2:
                setB = Ceast
            if dir == 0 and x ==3:
                setB = Cwest  

    #find A from C
    findA = (np.subtract(setB,setC))
    if findA[0] != 0:
        if findA[0] < 0:
            #south
            A = [setB[0]+2, setB[1]]
            print("A:",A)
        else:
            #north
            A = [setB[0]-2, setB[1]]
            print("A:",A)
    if findA[1] != 0:
        if findA[1] < 0:
            #east
            A = [setB[0], setB[1]+2]
            print("A:",A)
        else:
            #west
            A = [setB[0], setB[1]-2]
            print("A:",A)

    #set up varibles for A and C to test for open cells
    numfree = 0
    Anorth = [A[0]-1, A[1]]
    Asouth = [A[0]+1, A[1]]
    Aeast = [A[0], A[1]+1]
    Awest = [A[0], A[1]-1]
    acheck = [maze[Anorth[0],Anorth[1]], maze[Asouth[0], Asouth[1]],
            maze[Aeast[0], Aeast[1]], maze[Awest[0], Awest[1]]]

    #test A for open cells, if more than 2 delete C from walls
    #and go pick a new C to try again, delete c from walls
    for x, dir in enumerate(ccheck):
        if dir == 0:
            numfree +=1

    if numfree > 1:
        badwalls.append(walls[C])
        walls.remove(walls[C])

    #if C is good check A, if A is good then set A and C to 0
    #if A is bad then go pick a new C and remove C from walls
    if numfree <= 1:
        #numfree = 0
        for x, dir in enumerate(acheck):
            if dir == 0:
                numfree +=1

        if numfree <= 1:
            maze[A[0], A[1]] = 0
            maze[setC[0], setC[1]] = 0
            #look at each 0 cell and find walls that are good from it, add them to walls
            #to find a good wall see if adjacent cell is -1
            #if it is look if cell adjacent to that is -1
            #if it is add to walls
            print('HERE')
            wallcheck = []
            #create a list of cells that = 0, each of these should be checked for possible walls
            for indexr, row in enumerate(maze): 
                for indexc, num in enumerate(row):
                    if num == 0:
                        addwall = [indexr,indexc]
                        wallcheck.append(addwall)
                        #print('addwall',addwall)
                        print('wallcheck',wallcheck)
            #check each 0 cell for walls and add them to the wall list
            for ele in wallcheck:
                findwalls(ele)
            wallcheck.clear()
            #remove all bad walls from the wall list 
            for wall in badwalls:
                try:
                    walls.remove(wall)
                except:
                    pass
            # addwall.clear
        else:
            print("NO HERE")
            numfree = 2
            badwalls.append(walls[C])
            walls.remove(walls[C])

        #print("walls",walls)

    print(maze)
  