from turtle import fd
import numpy as np
import random

#set the size of the playable matrix
rows = 4
columns = 4

#create a matrix of the specified size then fill with -1's
maze = np.zeros((rows, columns))
maze.fill(-1)

#add padding around the maze :)
maze = np.pad(maze, pad_width=1, mode='constant', constant_values=-2)
print(maze)

walls = []

#put all legal indexes into walls
for indexr, row in enumerate(maze): 
        for indexc, num in enumerate(row):
            if maze[indexr, indexc] != -2:
                wall = [indexr, indexc]
                walls.append(wall)
print(walls)

while len(walls) > 0:
    #pick B from random index in walls and set to 0
    B = random.randint(0,len(walls)-1)
    setB = walls[B]
    print(setB[0])
    maze[setB[0], setB[1]] = 0
    print(maze)
    #remove this B from walls since its been used
    walls.remove(walls[B])

    #check the nextdoor neighbors (ndn) and 
    #the next nextdoor neighbots (nndn) to see if they are -1's
    north = [setB[0]-1, setB[1]]
    south = [setB[0]+1, setB[1]]
    east = [setB[0], setB[1]+1]
    west = [setB[0], setB[1]-1]
    ndn = [maze[north[0],north[1]], maze[south[0], south[1]],
           maze[east[0], east[1]], maze[west[0], west[1]]]
    directions = [north, south, east, west]

    fnorth = []
    fsouth = []
    feast = []
    fwest = []
    
    activewalls = []
    fdirections = ''

    #look at surrounding cells and check if they are -1
    #if they are add them to get looked at for 2 away
    for x, dir in enumerate(ndn):
        if dir == -1 and x == 0:
            fdirections += ' fnorth'
                    
        if dir == -1 and x == 1:
            fdirections += ' fsouth'

        if dir == -1 and x == 2:
            fdirections += ' feast'

        if dir == -1 and x == 3:
            fdirections += ' fwest'
    print(fdirections)

    #look at the numbers two away and see if they are -1
    #if they are add their keys to walls
    if 'fnorth' in fdirections:
        fnorth = [setB[0]-2, setB[1]]
        nfrows = fnorth[0] 
        nfcols = fnorth[1]
        if maze[nfrows, nfcols] == -1:
            activewalls.append(north)
        else:
            walls.remove(north) 

    if 'fsouth' in fdirections:
        fsouth = [setB[0]+2, setB[1]]
        sfrows = fsouth[0] 
        sfcols = fsouth[1]
        if maze[sfrows, sfcols] == -1:
            activewalls.append(south) 
        else:
            walls.remove(south) 

    if 'feast' in fdirections:
        feast = [setB[0], setB[1]+2]
        efrows = feast[0] 
        efcols = feast[1]
        if maze[efrows, efcols] == -1:
            activewalls.append(east)
        else:
            walls.remove(east) 

    if 'fwest' in fdirections:
        fwest = [setB[0], setB[1]-2]
        wfrows = fwest[0] 
        wfcols = fwest[1]
        if maze[wfrows, wfcols] == -1:
            activewalls.append(west)
        else:
            walls.remove(west) 
    print(walls)
    
    numfree = 2

    while numfree > 1:
        #pick C randomly from the list of walls
        C = random.randint(0,len(activewalls)-1)
        setC = activewalls[C]
        print(setC)

        #find A from C
        findA = (np.subtract(setB,setC))
        if findA[0] != 0:
            if findA[0] < 0:
                #south
                A = [setB[0]+2, setB[1]]
                print("A:",A)
            else:
                #north
                A = [setB[0]-2, setB[1]]
                print("A:",A)
        if findA[1] != 0:
            if findA[1] < 0:
                #east
                A = [setB[0], setB[1]+2]
                print("A:",A)
            else:
                #west
                A = [setB[0], setB[1]-2]
                print("A:",A)

        #set up varibles for A and C to test for open cells
        numfree = 0
        Anorth = [A[0]-1, A[1]]
        Asouth = [A[0]+1, A[1]]
        Aeast = [A[0], A[1]+1]
        Awest = [A[0], A[1]-1]
        acheck = [maze[Anorth[0],Anorth[1]], maze[Asouth[0], Asouth[1]],
            maze[Aeast[0], Aeast[1]], maze[Awest[0], Awest[1]]]

        Cnorth = [setC[0]-1, setC[1]]
        Csouth = [setC[0]+1, setC[1]]
        Ceast = [setC[0], setC[1]+1]
        Cwest = [setC[0], setC[1]-1]
        ccheck = [maze[Cnorth[0],Cnorth[1]], maze[Csouth[0], Csouth[1]],
            maze[Ceast[0], Ceast[1]], maze[Cwest[0], Cwest[1]]]

        #test A for open cells, if more than 2 delete A from walls
        #and go pick a new C to try again, delete c from activewalls
        for x, dir in enumerate(acheck):
            if dir == 0:
                numfree +=1
            print("hey",numfree)
        if numfree > 1:
            walls.remove(walls[A])
            activewalls.remove(walls[C])
            numfree = 2
            print("hi",numfree)
        print("here")
        numfree = 0
        #if A is good check C, if C is good then set A and C to 0
        #if C is bad then go pick a new C and remove C from walls and active walls
        if numfree <= 1:
            for x, dir in enumerate(ccheck):
                if dir == 0:
                    numfree +=1
                print("sup", numfree)
            print("hello")
            if numfree <= 1:
                maze[A[0], A[1]] = 0
                maze[setC[0], setC[1]] = 0
                print("ugh", numfree)
            else:
                numfree = 2
                activewalls.remove(walls[C])
                walls.remove(walls[C])














        # tocheck = [A, setC]
        # print('C:',setC)
        # for spot in tocheck:
        #     numfree = 0
        #     LoNorth = [spot[0]-1, spot[1]]
        #     LoSouth = [spot[0]+1, spot[1]]
        #     LoEast = [spot[0], spot[1]+1]
        #     LoWest = [spot[0], spot[1]-1]
        #     check = [maze[LoNorth[0],LoNorth[1]], maze[LoSouth[0], LoSouth[1]],
        #              maze[LoEast[0], LoEast[1]], maze[LoWest[0], LoWest[1]]]
        #     for spot in check:
        #         if spot == 0:
        #             numfree +=1
        #         if numfree <= 1:
        #             maze[A[0], A[1]] = 0
        #             maze[setC[0], setC[1]] = 0
        #             numfree = 0
        #         else:
        #             print(C)
        #             walls.remove(walls[C])
                
        print(walls)
    break


    print(maze)
  