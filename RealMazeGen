from turtle import fd
import numpy as np
import random

#set the size of the playable matrix
rows = 4
columns = 4

#create a matrix of the specified size then fill with -1's
maze = np.zeros((rows, columns))
maze.fill(-1)

#add padding around the maze :)
maze = np.pad(maze, pad_width=1, mode='constant', constant_values=-2)
print(maze)

walls = []

#put all legal indexes into walls
for indexr, row in enumerate(maze): 
        for indexc, num in enumerate(row):
            if maze[indexr, indexc] != -2:
                wall = [indexr, indexc]
                walls.append(wall)
print(walls)

while len(walls) > 0:
    #pick B from random index in walls and set to 0
    B = random.randint(0,len(walls)-1)
    setB = walls[B]
    print(setB[0])
    maze[setB[0], setB[1]] = 0
    print(maze)
    #remove this B from walls since its been used
    walls.remove(walls[B])

    #check the nextdoor neighbors (ndn) and 
    #the next nextdoor neighbots (nndn) to see if they are -1's
    north = [setB[0]-1, setB[1]]
    south = [setB[0]+1, setB[1]]
    east = [setB[0], setB[1]+1]
    west = [setB[0], setB[1]-1]
    ndn = [maze[north[0],north[1]], maze[south[0], south[1]],
           maze[east[0], east[1]], maze[west[0], west[1]]]
    directions = [north, south, east, west]

    fnorth = []
    fsouth = []
    feast = []
    fwest = []
    
    activewalls = []
    fdirections = ''

    #look at surrounding cells and check if they are -1
    #if they are add them to get looked at for 2 away
    for x, dir in enumerate(ndn):
        if dir == -1 and x == 0:
            fdirections += ' fnorth'
                    
        if dir == -1 and x == 1:
            fdirections += ' fsouth'

        if dir == -1 and x == 2:
            fdirections += ' feast'

        if dir == -1 and x == 3:
            fdirections += ' fwest'
    print(fdirections)

    #look at the numbers two away and see if they are -1
    #if they are add their keys to walls
    if 'fnorth' in fdirections:
        fnorth = [setB[0]-2, setB[1]]
        nfrows = fnorth[0] 
        nfcols = fnorth[1]
        if maze[nfrows, nfcols] == -1:
            activewalls.append(north)
        else:
            walls.remove(north) 

    if 'fsouth' in fdirections:
        fsouth = [setB[0]+2, setB[1]]
        sfrows = fsouth[0] 
        sfcols = fsouth[1]
        if maze[sfrows, sfcols] == -1:
            activewalls.append(south) 
        else:
            walls.remove(south) 

    if 'feast' in fdirections:
        feast = [setB[0], setB[1]+2]
        efrows = feast[0] 
        efcols = feast[1]
        if maze[efrows, efcols] == -1:
            activewalls.append(east)
        else:
            walls.remove(east) 

    if 'fwest' in fdirections:
        fwest = [setB[0], setB[1]-2]
        wfrows = fwest[0] 
        wfcols = fwest[1]
        if maze[wfrows, wfcols] == -1:
            activewalls.append(west)
        else:
            walls.remove(west) 
    print(walls)
    
    numfree = 2

    while numfree > 1:
        #pick C randomly from the list of walls
        C = random.randint(0,len(walls)-1)
        setC = walls[C]
        print(setC)

        #find A from C
        findA = (np.subtract(setB,setC))
        if findA[0] != 0:
            if findA[0] < 0:
                #south
                A = [setB[0]+2, setB[1]]
                print("A:",A)
            else:
                #north
                A = [setB[0]-2, setB[1]]
                print("A:",A)
        if findA[1] != 0:
            if findA[1] < 0:
                #east
                A = [setB[0], setB[1]+2]
                print("A:",A)
            else:
                #west
                A = [setB[0], setB[1]-2]
                print("A:",A)

        tocheck = [A, setC]
        print('C:',setC)
        for spot in tocheck:
            numfree = 0
            LoNorth = [spot[0]-1, spot[1]]
            LoSouth = [spot[0]+1, spot[1]]
            LoEast = [spot[0], spot[1]+1]
            LoWest = [spot[0], spot[1]-1]
            check = [maze[LoNorth[0],LoNorth[1]], maze[LoSouth[0], LoSouth[1]],
                     maze[LoEast[0], LoEast[1]], maze[LoWest[0], LoWest[1]]]
            for spot in check:
                if spot == 0:
                    numfree +=1
                if numfree <= 1:
                    maze[A[0], A[1]] = 0
                    maze[setC[0], setC[1]] = 0
                    numfree = 0
                else:
                    print(C)
                    walls.remove(walls[C])
                
        print(walls)
    break


    print(maze)
  