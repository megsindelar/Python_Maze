from asyncio import start_server
import numpy as np
import random

#set the size of the playable matrix
rows = 4
columns = 4

#create a matrix of the specified size then fill with -1's
maze = np.zeros((rows, columns))
maze.fill(-1)

#pick a start point denoted by 2
startc = random.randint(0,columns-1)
maze[0,startc] = 2

#add padding around the maze :)
maze = np.pad(maze, pad_width=1, mode='constant', constant_values=-2)
print(maze)

#generate maze path
#identify walls cells
walls = []

#look for a 0 or a 2 to find walls
for indexr, row in enumerate(maze): 
    for indexc, num in enumerate(row):
        if num == 2 or num == 0:
            B = [indexr, indexc]
            print("B:",B)
            north = [indexr+1, indexc]
            south = [indexr-1, indexc]
            east = [indexr, indexc+1]
            west = [indexr, indexc-1]
            cardinal = ''
            directions = [north, south, east, west]
            neighbors = [maze[north[0],north[1]], maze[south[0], south[1]], maze[east[0], east[1]], maze[west[0], west[1]]]
            #add all of the surround cells to walls
            for x, dir in enumerate(neighbors):
                if dir == -1 and x == 0:
                    walls.append(north)
                if dir == -1 and x == 1:
                    walls.append(south)
                if dir == -1 and x == 2:
                    walls.append(east)
                if dir == -1 and x == 3:
                    walls.append(west)
                
            print("walls:",walls)


#randomly pick C from walls
walllen = len(walls)
CinWall =random.randint(0,walllen-1)
C = walls[CinWall]
print("C:",C)

#find A from C
findA = (np.subtract(B,C))

if findA[0] != 0:
    if findA[0] < 0:
        #south
        A = [B[0]+2, B[1]]
        print("A:",A)
    else:
        #north
        A = [B[0]-2, B[1]]
        print("A:",A)
if findA[1] != 0:
    if findA[1] < 0:
        #east
        A = [B[0], B[1]+2]
        print("A:",A)
    else:
        #west
        A = [B[0], B[1]-2]
        print("A:",A)

#check for 2 or more free cells around A
#if there are 2 or more then remove C from walls 
#if there are not 2 or more then open A and C
potfree = [A, C]
print(potfree)
remWall = 0
for spot in potfree:
    numfree = 0
    LoNorth = [spot[0]+1, spot[1]]
    LoSouth = [spot[0]-1, spot[1]]
    LoEast = [spot[0], spot[1]+1]
    LoWest = [spot[0], spot[1]-1]
    check = [maze[LoNorth[0],LoNorth[1]], maze[LoSouth[0], LoSouth[1]], maze[LoEast[0], LoEast[1]], maze[LoWest[0], LoWest[1]]]
    for spot in check:
        if spot == 0 or spot ==2:
            numfree +=1
    if numfree > 1:
        walls.remove(walls[CinWall])
        print(walls)
    elif numfree < 2:
        remWall +=1
if remWall == 2:
    maze[A[0],A[1]] = 0
    maze[C[0], C[1]] = 0

print(maze)






#pick an end point denoted by 3
#endc = random.randint(0,columns)